// Quantities can model external quantity types
// Apples and oranges as different units 
// are abstracted away by the model
CAR: set;
CAR_UNIT(CAR): quantity;

B52_TARGETS: set;
{murica}; // singleton;
COUNTRY: {murica} | B52_TARGETS; //disjoint union/sum type

FUNNY_MONEY(B52_TARGETS): quantity;
`$`: quantity;
CURRENCY_UNIT := `$` | disjoint{t: B52_TARGETS @ FUNNY_MONEY(t) }; //disjoint union/sum type (units are types not values)

CURRENCY: c: COUNTRY -> CURRENCY_UNIT 
    ::= c ?   // pattern match on sum type
        {murica} -> `$`,
        FUNNY_MONEY(c); // type narrowwing

CarPrice: (c: CAR) -> `$`/CAR_UNIT(c);

InternationalCarPrice: (country: COUNTRY, car: CAR) -> CURRENCY(country)/CAR_UNIT(car);

// Dimensions and arithmetic are checked 
// No adding of apples to oranges
ill-formed-begin
    TotalWrong := sum{a:CAR} CarPrice(a); 
ill-formed-end

TotalRight := sum{a:CAR} CarPrice(a)*CAR_UNIT(a); 
assert( typeof(TotalRight) = `$`);