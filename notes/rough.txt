https://www.home.emcsg.com/about-the-market/rules/market-rules

discrete indices ticks slots intervals left right all  length HOUR & MINUTE & SECOND

left/begin right/end

indices and slots are ordered sets

https://chatgpt.com/share/68c3e33c-ba98-8010-8199-4d7440f8fe60

s as <a, b, c>

order vs sequence

CITYT = A | B | C 

https://chatgpt.com/share/68bb7ae4-2c1c-8010-8662-4f37347dcfef

module A.B includes A

include A implies A.*

model query problem projection.          BlahVar: boolvar   KKVar: intval.   NNVat:floatvar.      BlahVar <-> AbSet & CcSet;        problem ....

implementation   lookup(lazy, eager) procedure(MEMOIZED:bool).  id_type.   sql, host_method EAGER, LAZY, LAZY_AND_MEMOIZED, model(projection_params)

[...] typed sequence. <> tuple,  { } structured compound expressions, () explict order of evaluation, siambiguation, function arguments 

traverse(x:OrderedSet) {....    produces a sequence  fold???? fold(binaryop, init_value) {}

enum { EAGER, LAZY, LAZY_MEMOIZED};
    CarID addCard();
    enum {  }
    void setLoadCarsLazy(bool);
    void LoadCars(Car)

inline csharp and adonet    

/FiniteType/
/FiniteSet/
/MaximalSet/
/NullSet/

`forall`, `sequences` prose and code comments
forall{x: sequences(4, CITY) | forall{y: x} @  )
[a, b, c, d]: CITY
module Accounting
model Blah
include ParentBlah
data OptionalName
include Blah
query BillPerMonth
bindings
x: Month
results

using standard.line;
TIME_MODEL_DAY: discretized_finite(24);
HOUR_SEGMENT : discretized_segment(TIME_MODEL_DAY);
HOURS_INTERVAL : discretized_interval(TIME_MODEL_DAY);
HOUR_POINT : discretized_point(TIME_MODEL_DAY);
HOUR_SEGMENT_INDEX : segment_index(TIME_MODEL_DAY);
POINT_SEGMENT_INDEX : segment_index(TIME_MODEL_DAY);
CONSECUTIVE : 
TIME_MODEL_HOUR: discretized_finite(60);
MINUTE_SEGMENT : discretized_segment(TIME_MODEL_HOUR);
MINUTE_INTERVAL : discretized_interval(TIME_MODEL_HOUR);
MINUTE_POINT : discretized_point(TIME_MODEL_HOUR);
MINUTE_SEGMENT_INDEX : segment_index(TIME_MODEL_HOUR);
MINUTE_SEGMENT_INDEX : segment_index(TIME_MODEL_HOUR);
MINUTE_SEGMENTS_OF_DAY alias HOUR_SEGMENT & MINUTE_SEGMENT  
using standard.sequence;
IS_BEFORE : A -> A - > bool;
cyclic
sequence
subsequence
using standard.arithmetic;

https://chatgpt.com/share/68affa55-cf34-8010-b177-593f3a4250cb

https://chatgpt.com/share/68affa25-1f1c-8010-ba5e-21a1c4966bea

boolexpr ? val_if_true, val_if_alse
x <= 5  ?  4 ,
x <=10  ? 17 ,
x <= 19 ?  5 ,
           3 ;

partitions
S = P1 | P2 | P3 | P4 | P5; 
x: S;
f: P4 -> N0';
g: S -> integer;

x ? P1 | P2 -> 7 ,
    P3 -> 8 ,
    y: P4 -> f(y) ,
    P5 -> g(x), 
    10 ;

forall, exists, unique

x: nullable(integer);
x ? value y -> y , 15;

f:S -> nullable(integer);
x: { x:S: valued(f(x)) };

f1:S +> integer;
x: domain(f1);

f:A->B; // function, alternative notation '1,n--0,1' // All A's have a B, some B's have no A, some B's have the same A
f:A+>B; partial function, alternative notation  '0,n--0,1' // Some A's have a B, some B's have no A, some B's have the same A
f:A->>B; // injection  A >->> codomain(f), alternative notation '1--0,1 '// All A's have a B, some B's have no A, no two B's have the same A
f:A >-> B; // surjection   codomain(f) = B, alternative notation  '1,n--1' // All A's have a B, all B's have an A, some B's have the same A
f:A >->> B; // bijection, alternative notation '1--1'   

not, and, or

A & B // cartesion
A | B // disjoint union / sum type
A <' B // strict subset
A <=' B // subset
A n' B // intersection
A u' B // union
x in A // set membership

union{x: ....}
intersection{... }
sum{... }
forall{...}
exists{...}
unique{...}

powerset(A) 

A: set; // FiniteType, MaximalSet
X: ordered; // FiniteType, MaximalSet

B: powerset(A); // FiniteSet

C: order(A);

forall{[from, to]: X |  }
forall{[from, _, to]: C |  }

forall{s: sequences(n, C) | forall{ m:? :...s@m...  } // to do

DAY: discrete(24);
HOUR: indices(DAY);

LunchHour: HOUR;

Lunch: slots(DAY);
Lunch = slot(LunchHour);

LunchStart: ticks(DAY);
LunchEnd: ticks(DAY);
LunchStart = left(LunchHour);
LunchEnd = right(LunchHour);

SpecialLunch: intervals(DAY);
length(LunchHour) = 1;
length(SpecialLunch) = 2;
[h1, h2]: SpecialLunch;

model;

data; // tests, examples

query; // transaction script

problem; // model for external optimizer, algorithm


B: P'(A);  // B subset of a
B <' C;
B <=' C;
B u' C;
B n' C;

a in' A;
a not' A;

B | C | D;
A & B & C;

forall{}
exists{}
unique{}
union{}
intersection/inter{}
sum{}
product/prod{}
maximum/max{}
minimum/min{}
average/avg{}

cardinality/card


Z'
Q'
R'
N0'
N1'

R'(..Blah);

decimal : reify(R');
float1 : reify(R'); 

smalln: reify(N1');
smalln(2..Blah);

not or and

Syntelion indices start from 0

<. > // tuple
() // function application, associativity disambiguation

[,] // sequence/bijection 
length([])
slice: N1, ...

